// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Grpc/rpc.proto
// </auto-generated>
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace Lnrpc {
  /// <summary>
  /// Lightning is the main RPC server of the daemon.
  /// </summary>
  public static partial class Lightning
  {
    static readonly string __ServiceName = "lnrpc.Lightning";

    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    static readonly grpc::Marshaller<global::Lnrpc.WalletBalanceRequest> __Marshaller_lnrpc_WalletBalanceRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.WalletBalanceRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.WalletBalanceResponse> __Marshaller_lnrpc_WalletBalanceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.WalletBalanceResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelBalanceRequest> __Marshaller_lnrpc_ChannelBalanceRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelBalanceRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelBalanceResponse> __Marshaller_lnrpc_ChannelBalanceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelBalanceResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.GetTransactionsRequest> __Marshaller_lnrpc_GetTransactionsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.GetTransactionsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.TransactionDetails> __Marshaller_lnrpc_TransactionDetails = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.TransactionDetails.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.EstimateFeeRequest> __Marshaller_lnrpc_EstimateFeeRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.EstimateFeeRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.EstimateFeeResponse> __Marshaller_lnrpc_EstimateFeeResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.EstimateFeeResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SendCoinsRequest> __Marshaller_lnrpc_SendCoinsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SendCoinsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SendCoinsResponse> __Marshaller_lnrpc_SendCoinsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SendCoinsResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListUnspentRequest> __Marshaller_lnrpc_ListUnspentRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListUnspentRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListUnspentResponse> __Marshaller_lnrpc_ListUnspentResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListUnspentResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.Transaction> __Marshaller_lnrpc_Transaction = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.Transaction.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SendManyRequest> __Marshaller_lnrpc_SendManyRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SendManyRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SendManyResponse> __Marshaller_lnrpc_SendManyResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SendManyResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.NewAddressRequest> __Marshaller_lnrpc_NewAddressRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.NewAddressRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.NewAddressResponse> __Marshaller_lnrpc_NewAddressResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.NewAddressResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SignMessageRequest> __Marshaller_lnrpc_SignMessageRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SignMessageRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SignMessageResponse> __Marshaller_lnrpc_SignMessageResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SignMessageResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.VerifyMessageRequest> __Marshaller_lnrpc_VerifyMessageRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.VerifyMessageRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.VerifyMessageResponse> __Marshaller_lnrpc_VerifyMessageResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.VerifyMessageResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ConnectPeerRequest> __Marshaller_lnrpc_ConnectPeerRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ConnectPeerRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ConnectPeerResponse> __Marshaller_lnrpc_ConnectPeerResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ConnectPeerResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.DisconnectPeerRequest> __Marshaller_lnrpc_DisconnectPeerRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.DisconnectPeerRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.DisconnectPeerResponse> __Marshaller_lnrpc_DisconnectPeerResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.DisconnectPeerResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListPeersRequest> __Marshaller_lnrpc_ListPeersRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListPeersRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListPeersResponse> __Marshaller_lnrpc_ListPeersResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListPeersResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PeerEventSubscription> __Marshaller_lnrpc_PeerEventSubscription = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PeerEventSubscription.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PeerEvent> __Marshaller_lnrpc_PeerEvent = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PeerEvent.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.GetInfoRequest> __Marshaller_lnrpc_GetInfoRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.GetInfoRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.GetInfoResponse> __Marshaller_lnrpc_GetInfoResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.GetInfoResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.GetRecoveryInfoRequest> __Marshaller_lnrpc_GetRecoveryInfoRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.GetRecoveryInfoRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.GetRecoveryInfoResponse> __Marshaller_lnrpc_GetRecoveryInfoResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.GetRecoveryInfoResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PendingChannelsRequest> __Marshaller_lnrpc_PendingChannelsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PendingChannelsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PendingChannelsResponse> __Marshaller_lnrpc_PendingChannelsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PendingChannelsResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListChannelsRequest> __Marshaller_lnrpc_ListChannelsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListChannelsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListChannelsResponse> __Marshaller_lnrpc_ListChannelsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListChannelsResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelEventSubscription> __Marshaller_lnrpc_ChannelEventSubscription = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelEventSubscription.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelEventUpdate> __Marshaller_lnrpc_ChannelEventUpdate = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelEventUpdate.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ClosedChannelsRequest> __Marshaller_lnrpc_ClosedChannelsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ClosedChannelsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ClosedChannelsResponse> __Marshaller_lnrpc_ClosedChannelsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ClosedChannelsResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.OpenChannelRequest> __Marshaller_lnrpc_OpenChannelRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.OpenChannelRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelPoint> __Marshaller_lnrpc_ChannelPoint = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelPoint.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.OpenStatusUpdate> __Marshaller_lnrpc_OpenStatusUpdate = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.OpenStatusUpdate.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.FundingTransitionMsg> __Marshaller_lnrpc_FundingTransitionMsg = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.FundingTransitionMsg.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.FundingStateStepResp> __Marshaller_lnrpc_FundingStateStepResp = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.FundingStateStepResp.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelAcceptResponse> __Marshaller_lnrpc_ChannelAcceptResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelAcceptResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelAcceptRequest> __Marshaller_lnrpc_ChannelAcceptRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelAcceptRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.CloseChannelRequest> __Marshaller_lnrpc_CloseChannelRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.CloseChannelRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.CloseStatusUpdate> __Marshaller_lnrpc_CloseStatusUpdate = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.CloseStatusUpdate.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.AbandonChannelRequest> __Marshaller_lnrpc_AbandonChannelRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.AbandonChannelRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.AbandonChannelResponse> __Marshaller_lnrpc_AbandonChannelResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.AbandonChannelResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SendRequest> __Marshaller_lnrpc_SendRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SendRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SendResponse> __Marshaller_lnrpc_SendResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SendResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.SendToRouteRequest> __Marshaller_lnrpc_SendToRouteRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.SendToRouteRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.Invoice> __Marshaller_lnrpc_Invoice = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.Invoice.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.AddInvoiceResponse> __Marshaller_lnrpc_AddInvoiceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.AddInvoiceResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListInvoiceRequest> __Marshaller_lnrpc_ListInvoiceRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListInvoiceRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListInvoiceResponse> __Marshaller_lnrpc_ListInvoiceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListInvoiceResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PaymentHash> __Marshaller_lnrpc_PaymentHash = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PaymentHash.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.InvoiceSubscription> __Marshaller_lnrpc_InvoiceSubscription = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.InvoiceSubscription.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PayReqString> __Marshaller_lnrpc_PayReqString = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PayReqString.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PayReq> __Marshaller_lnrpc_PayReq = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PayReq.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListPaymentsRequest> __Marshaller_lnrpc_ListPaymentsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListPaymentsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListPaymentsResponse> __Marshaller_lnrpc_ListPaymentsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListPaymentsResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.DeleteAllPaymentsRequest> __Marshaller_lnrpc_DeleteAllPaymentsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.DeleteAllPaymentsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.DeleteAllPaymentsResponse> __Marshaller_lnrpc_DeleteAllPaymentsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.DeleteAllPaymentsResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelGraphRequest> __Marshaller_lnrpc_ChannelGraphRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelGraphRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelGraph> __Marshaller_lnrpc_ChannelGraph = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelGraph.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.NodeMetricsRequest> __Marshaller_lnrpc_NodeMetricsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.NodeMetricsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.NodeMetricsResponse> __Marshaller_lnrpc_NodeMetricsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.NodeMetricsResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChanInfoRequest> __Marshaller_lnrpc_ChanInfoRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChanInfoRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelEdge> __Marshaller_lnrpc_ChannelEdge = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelEdge.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.NodeInfoRequest> __Marshaller_lnrpc_NodeInfoRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.NodeInfoRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.NodeInfo> __Marshaller_lnrpc_NodeInfo = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.NodeInfo.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.QueryRoutesRequest> __Marshaller_lnrpc_QueryRoutesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.QueryRoutesRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.QueryRoutesResponse> __Marshaller_lnrpc_QueryRoutesResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.QueryRoutesResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.NetworkInfoRequest> __Marshaller_lnrpc_NetworkInfoRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.NetworkInfoRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.NetworkInfo> __Marshaller_lnrpc_NetworkInfo = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.NetworkInfo.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.StopRequest> __Marshaller_lnrpc_StopRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.StopRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.StopResponse> __Marshaller_lnrpc_StopResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.StopResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.GraphTopologySubscription> __Marshaller_lnrpc_GraphTopologySubscription = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.GraphTopologySubscription.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.GraphTopologyUpdate> __Marshaller_lnrpc_GraphTopologyUpdate = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.GraphTopologyUpdate.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.DebugLevelRequest> __Marshaller_lnrpc_DebugLevelRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.DebugLevelRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.DebugLevelResponse> __Marshaller_lnrpc_DebugLevelResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.DebugLevelResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.FeeReportRequest> __Marshaller_lnrpc_FeeReportRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.FeeReportRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.FeeReportResponse> __Marshaller_lnrpc_FeeReportResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.FeeReportResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PolicyUpdateRequest> __Marshaller_lnrpc_PolicyUpdateRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PolicyUpdateRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.PolicyUpdateResponse> __Marshaller_lnrpc_PolicyUpdateResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.PolicyUpdateResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ForwardingHistoryRequest> __Marshaller_lnrpc_ForwardingHistoryRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ForwardingHistoryRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ForwardingHistoryResponse> __Marshaller_lnrpc_ForwardingHistoryResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ForwardingHistoryResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ExportChannelBackupRequest> __Marshaller_lnrpc_ExportChannelBackupRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ExportChannelBackupRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelBackup> __Marshaller_lnrpc_ChannelBackup = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelBackup.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChanBackupExportRequest> __Marshaller_lnrpc_ChanBackupExportRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChanBackupExportRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChanBackupSnapshot> __Marshaller_lnrpc_ChanBackupSnapshot = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChanBackupSnapshot.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.VerifyChanBackupResponse> __Marshaller_lnrpc_VerifyChanBackupResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.VerifyChanBackupResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.RestoreChanBackupRequest> __Marshaller_lnrpc_RestoreChanBackupRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.RestoreChanBackupRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.RestoreBackupResponse> __Marshaller_lnrpc_RestoreBackupResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.RestoreBackupResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ChannelBackupSubscription> __Marshaller_lnrpc_ChannelBackupSubscription = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ChannelBackupSubscription.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.BakeMacaroonRequest> __Marshaller_lnrpc_BakeMacaroonRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.BakeMacaroonRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.BakeMacaroonResponse> __Marshaller_lnrpc_BakeMacaroonResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.BakeMacaroonResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListMacaroonIDsRequest> __Marshaller_lnrpc_ListMacaroonIDsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListMacaroonIDsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListMacaroonIDsResponse> __Marshaller_lnrpc_ListMacaroonIDsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListMacaroonIDsResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.DeleteMacaroonIDRequest> __Marshaller_lnrpc_DeleteMacaroonIDRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.DeleteMacaroonIDRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.DeleteMacaroonIDResponse> __Marshaller_lnrpc_DeleteMacaroonIDResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.DeleteMacaroonIDResponse.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListPermissionsRequest> __Marshaller_lnrpc_ListPermissionsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListPermissionsRequest.Parser));
    static readonly grpc::Marshaller<global::Lnrpc.ListPermissionsResponse> __Marshaller_lnrpc_ListPermissionsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::Lnrpc.ListPermissionsResponse.Parser));

    static readonly grpc::Method<global::Lnrpc.WalletBalanceRequest, global::Lnrpc.WalletBalanceResponse> __Method_WalletBalance = new grpc::Method<global::Lnrpc.WalletBalanceRequest, global::Lnrpc.WalletBalanceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "WalletBalance",
        __Marshaller_lnrpc_WalletBalanceRequest,
        __Marshaller_lnrpc_WalletBalanceResponse);

    static readonly grpc::Method<global::Lnrpc.ChannelBalanceRequest, global::Lnrpc.ChannelBalanceResponse> __Method_ChannelBalance = new grpc::Method<global::Lnrpc.ChannelBalanceRequest, global::Lnrpc.ChannelBalanceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ChannelBalance",
        __Marshaller_lnrpc_ChannelBalanceRequest,
        __Marshaller_lnrpc_ChannelBalanceResponse);

    static readonly grpc::Method<global::Lnrpc.GetTransactionsRequest, global::Lnrpc.TransactionDetails> __Method_GetTransactions = new grpc::Method<global::Lnrpc.GetTransactionsRequest, global::Lnrpc.TransactionDetails>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetTransactions",
        __Marshaller_lnrpc_GetTransactionsRequest,
        __Marshaller_lnrpc_TransactionDetails);

    static readonly grpc::Method<global::Lnrpc.EstimateFeeRequest, global::Lnrpc.EstimateFeeResponse> __Method_EstimateFee = new grpc::Method<global::Lnrpc.EstimateFeeRequest, global::Lnrpc.EstimateFeeResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "EstimateFee",
        __Marshaller_lnrpc_EstimateFeeRequest,
        __Marshaller_lnrpc_EstimateFeeResponse);

    static readonly grpc::Method<global::Lnrpc.SendCoinsRequest, global::Lnrpc.SendCoinsResponse> __Method_SendCoins = new grpc::Method<global::Lnrpc.SendCoinsRequest, global::Lnrpc.SendCoinsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendCoins",
        __Marshaller_lnrpc_SendCoinsRequest,
        __Marshaller_lnrpc_SendCoinsResponse);

    static readonly grpc::Method<global::Lnrpc.ListUnspentRequest, global::Lnrpc.ListUnspentResponse> __Method_ListUnspent = new grpc::Method<global::Lnrpc.ListUnspentRequest, global::Lnrpc.ListUnspentResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListUnspent",
        __Marshaller_lnrpc_ListUnspentRequest,
        __Marshaller_lnrpc_ListUnspentResponse);

    static readonly grpc::Method<global::Lnrpc.GetTransactionsRequest, global::Lnrpc.Transaction> __Method_SubscribeTransactions = new grpc::Method<global::Lnrpc.GetTransactionsRequest, global::Lnrpc.Transaction>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribeTransactions",
        __Marshaller_lnrpc_GetTransactionsRequest,
        __Marshaller_lnrpc_Transaction);

    static readonly grpc::Method<global::Lnrpc.SendManyRequest, global::Lnrpc.SendManyResponse> __Method_SendMany = new grpc::Method<global::Lnrpc.SendManyRequest, global::Lnrpc.SendManyResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendMany",
        __Marshaller_lnrpc_SendManyRequest,
        __Marshaller_lnrpc_SendManyResponse);

    static readonly grpc::Method<global::Lnrpc.NewAddressRequest, global::Lnrpc.NewAddressResponse> __Method_NewAddress = new grpc::Method<global::Lnrpc.NewAddressRequest, global::Lnrpc.NewAddressResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "NewAddress",
        __Marshaller_lnrpc_NewAddressRequest,
        __Marshaller_lnrpc_NewAddressResponse);

    static readonly grpc::Method<global::Lnrpc.SignMessageRequest, global::Lnrpc.SignMessageResponse> __Method_SignMessage = new grpc::Method<global::Lnrpc.SignMessageRequest, global::Lnrpc.SignMessageResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SignMessage",
        __Marshaller_lnrpc_SignMessageRequest,
        __Marshaller_lnrpc_SignMessageResponse);

    static readonly grpc::Method<global::Lnrpc.VerifyMessageRequest, global::Lnrpc.VerifyMessageResponse> __Method_VerifyMessage = new grpc::Method<global::Lnrpc.VerifyMessageRequest, global::Lnrpc.VerifyMessageResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "VerifyMessage",
        __Marshaller_lnrpc_VerifyMessageRequest,
        __Marshaller_lnrpc_VerifyMessageResponse);

    static readonly grpc::Method<global::Lnrpc.ConnectPeerRequest, global::Lnrpc.ConnectPeerResponse> __Method_ConnectPeer = new grpc::Method<global::Lnrpc.ConnectPeerRequest, global::Lnrpc.ConnectPeerResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ConnectPeer",
        __Marshaller_lnrpc_ConnectPeerRequest,
        __Marshaller_lnrpc_ConnectPeerResponse);

    static readonly grpc::Method<global::Lnrpc.DisconnectPeerRequest, global::Lnrpc.DisconnectPeerResponse> __Method_DisconnectPeer = new grpc::Method<global::Lnrpc.DisconnectPeerRequest, global::Lnrpc.DisconnectPeerResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DisconnectPeer",
        __Marshaller_lnrpc_DisconnectPeerRequest,
        __Marshaller_lnrpc_DisconnectPeerResponse);

    static readonly grpc::Method<global::Lnrpc.ListPeersRequest, global::Lnrpc.ListPeersResponse> __Method_ListPeers = new grpc::Method<global::Lnrpc.ListPeersRequest, global::Lnrpc.ListPeersResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListPeers",
        __Marshaller_lnrpc_ListPeersRequest,
        __Marshaller_lnrpc_ListPeersResponse);

    static readonly grpc::Method<global::Lnrpc.PeerEventSubscription, global::Lnrpc.PeerEvent> __Method_SubscribePeerEvents = new grpc::Method<global::Lnrpc.PeerEventSubscription, global::Lnrpc.PeerEvent>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribePeerEvents",
        __Marshaller_lnrpc_PeerEventSubscription,
        __Marshaller_lnrpc_PeerEvent);

    static readonly grpc::Method<global::Lnrpc.GetInfoRequest, global::Lnrpc.GetInfoResponse> __Method_GetInfo = new grpc::Method<global::Lnrpc.GetInfoRequest, global::Lnrpc.GetInfoResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetInfo",
        __Marshaller_lnrpc_GetInfoRequest,
        __Marshaller_lnrpc_GetInfoResponse);

    static readonly grpc::Method<global::Lnrpc.GetRecoveryInfoRequest, global::Lnrpc.GetRecoveryInfoResponse> __Method_GetRecoveryInfo = new grpc::Method<global::Lnrpc.GetRecoveryInfoRequest, global::Lnrpc.GetRecoveryInfoResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetRecoveryInfo",
        __Marshaller_lnrpc_GetRecoveryInfoRequest,
        __Marshaller_lnrpc_GetRecoveryInfoResponse);

    static readonly grpc::Method<global::Lnrpc.PendingChannelsRequest, global::Lnrpc.PendingChannelsResponse> __Method_PendingChannels = new grpc::Method<global::Lnrpc.PendingChannelsRequest, global::Lnrpc.PendingChannelsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PendingChannels",
        __Marshaller_lnrpc_PendingChannelsRequest,
        __Marshaller_lnrpc_PendingChannelsResponse);

    static readonly grpc::Method<global::Lnrpc.ListChannelsRequest, global::Lnrpc.ListChannelsResponse> __Method_ListChannels = new grpc::Method<global::Lnrpc.ListChannelsRequest, global::Lnrpc.ListChannelsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListChannels",
        __Marshaller_lnrpc_ListChannelsRequest,
        __Marshaller_lnrpc_ListChannelsResponse);

    static readonly grpc::Method<global::Lnrpc.ChannelEventSubscription, global::Lnrpc.ChannelEventUpdate> __Method_SubscribeChannelEvents = new grpc::Method<global::Lnrpc.ChannelEventSubscription, global::Lnrpc.ChannelEventUpdate>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribeChannelEvents",
        __Marshaller_lnrpc_ChannelEventSubscription,
        __Marshaller_lnrpc_ChannelEventUpdate);

    static readonly grpc::Method<global::Lnrpc.ClosedChannelsRequest, global::Lnrpc.ClosedChannelsResponse> __Method_ClosedChannels = new grpc::Method<global::Lnrpc.ClosedChannelsRequest, global::Lnrpc.ClosedChannelsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ClosedChannels",
        __Marshaller_lnrpc_ClosedChannelsRequest,
        __Marshaller_lnrpc_ClosedChannelsResponse);

    static readonly grpc::Method<global::Lnrpc.OpenChannelRequest, global::Lnrpc.ChannelPoint> __Method_OpenChannelSync = new grpc::Method<global::Lnrpc.OpenChannelRequest, global::Lnrpc.ChannelPoint>(
        grpc::MethodType.Unary,
        __ServiceName,
        "OpenChannelSync",
        __Marshaller_lnrpc_OpenChannelRequest,
        __Marshaller_lnrpc_ChannelPoint);

    static readonly grpc::Method<global::Lnrpc.OpenChannelRequest, global::Lnrpc.OpenStatusUpdate> __Method_OpenChannel = new grpc::Method<global::Lnrpc.OpenChannelRequest, global::Lnrpc.OpenStatusUpdate>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "OpenChannel",
        __Marshaller_lnrpc_OpenChannelRequest,
        __Marshaller_lnrpc_OpenStatusUpdate);

    static readonly grpc::Method<global::Lnrpc.FundingTransitionMsg, global::Lnrpc.FundingStateStepResp> __Method_FundingStateStep = new grpc::Method<global::Lnrpc.FundingTransitionMsg, global::Lnrpc.FundingStateStepResp>(
        grpc::MethodType.Unary,
        __ServiceName,
        "FundingStateStep",
        __Marshaller_lnrpc_FundingTransitionMsg,
        __Marshaller_lnrpc_FundingStateStepResp);

    static readonly grpc::Method<global::Lnrpc.ChannelAcceptResponse, global::Lnrpc.ChannelAcceptRequest> __Method_ChannelAcceptor = new grpc::Method<global::Lnrpc.ChannelAcceptResponse, global::Lnrpc.ChannelAcceptRequest>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "ChannelAcceptor",
        __Marshaller_lnrpc_ChannelAcceptResponse,
        __Marshaller_lnrpc_ChannelAcceptRequest);

    static readonly grpc::Method<global::Lnrpc.CloseChannelRequest, global::Lnrpc.CloseStatusUpdate> __Method_CloseChannel = new grpc::Method<global::Lnrpc.CloseChannelRequest, global::Lnrpc.CloseStatusUpdate>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "CloseChannel",
        __Marshaller_lnrpc_CloseChannelRequest,
        __Marshaller_lnrpc_CloseStatusUpdate);

    static readonly grpc::Method<global::Lnrpc.AbandonChannelRequest, global::Lnrpc.AbandonChannelResponse> __Method_AbandonChannel = new grpc::Method<global::Lnrpc.AbandonChannelRequest, global::Lnrpc.AbandonChannelResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "AbandonChannel",
        __Marshaller_lnrpc_AbandonChannelRequest,
        __Marshaller_lnrpc_AbandonChannelResponse);

    static readonly grpc::Method<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse> __Method_SendPayment = new grpc::Method<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "SendPayment",
        __Marshaller_lnrpc_SendRequest,
        __Marshaller_lnrpc_SendResponse);

    static readonly grpc::Method<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse> __Method_SendPaymentSync = new grpc::Method<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendPaymentSync",
        __Marshaller_lnrpc_SendRequest,
        __Marshaller_lnrpc_SendResponse);

    static readonly grpc::Method<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse> __Method_SendToRoute = new grpc::Method<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "SendToRoute",
        __Marshaller_lnrpc_SendToRouteRequest,
        __Marshaller_lnrpc_SendResponse);

    static readonly grpc::Method<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse> __Method_SendToRouteSync = new grpc::Method<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendToRouteSync",
        __Marshaller_lnrpc_SendToRouteRequest,
        __Marshaller_lnrpc_SendResponse);

    static readonly grpc::Method<global::Lnrpc.Invoice, global::Lnrpc.AddInvoiceResponse> __Method_AddInvoice = new grpc::Method<global::Lnrpc.Invoice, global::Lnrpc.AddInvoiceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "AddInvoice",
        __Marshaller_lnrpc_Invoice,
        __Marshaller_lnrpc_AddInvoiceResponse);

    static readonly grpc::Method<global::Lnrpc.ListInvoiceRequest, global::Lnrpc.ListInvoiceResponse> __Method_ListInvoices = new grpc::Method<global::Lnrpc.ListInvoiceRequest, global::Lnrpc.ListInvoiceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListInvoices",
        __Marshaller_lnrpc_ListInvoiceRequest,
        __Marshaller_lnrpc_ListInvoiceResponse);

    static readonly grpc::Method<global::Lnrpc.PaymentHash, global::Lnrpc.Invoice> __Method_LookupInvoice = new grpc::Method<global::Lnrpc.PaymentHash, global::Lnrpc.Invoice>(
        grpc::MethodType.Unary,
        __ServiceName,
        "LookupInvoice",
        __Marshaller_lnrpc_PaymentHash,
        __Marshaller_lnrpc_Invoice);

    static readonly grpc::Method<global::Lnrpc.InvoiceSubscription, global::Lnrpc.Invoice> __Method_SubscribeInvoices = new grpc::Method<global::Lnrpc.InvoiceSubscription, global::Lnrpc.Invoice>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribeInvoices",
        __Marshaller_lnrpc_InvoiceSubscription,
        __Marshaller_lnrpc_Invoice);

    static readonly grpc::Method<global::Lnrpc.PayReqString, global::Lnrpc.PayReq> __Method_DecodePayReq = new grpc::Method<global::Lnrpc.PayReqString, global::Lnrpc.PayReq>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DecodePayReq",
        __Marshaller_lnrpc_PayReqString,
        __Marshaller_lnrpc_PayReq);

    static readonly grpc::Method<global::Lnrpc.ListPaymentsRequest, global::Lnrpc.ListPaymentsResponse> __Method_ListPayments = new grpc::Method<global::Lnrpc.ListPaymentsRequest, global::Lnrpc.ListPaymentsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListPayments",
        __Marshaller_lnrpc_ListPaymentsRequest,
        __Marshaller_lnrpc_ListPaymentsResponse);

    static readonly grpc::Method<global::Lnrpc.DeleteAllPaymentsRequest, global::Lnrpc.DeleteAllPaymentsResponse> __Method_DeleteAllPayments = new grpc::Method<global::Lnrpc.DeleteAllPaymentsRequest, global::Lnrpc.DeleteAllPaymentsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeleteAllPayments",
        __Marshaller_lnrpc_DeleteAllPaymentsRequest,
        __Marshaller_lnrpc_DeleteAllPaymentsResponse);

    static readonly grpc::Method<global::Lnrpc.ChannelGraphRequest, global::Lnrpc.ChannelGraph> __Method_DescribeGraph = new grpc::Method<global::Lnrpc.ChannelGraphRequest, global::Lnrpc.ChannelGraph>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DescribeGraph",
        __Marshaller_lnrpc_ChannelGraphRequest,
        __Marshaller_lnrpc_ChannelGraph);

    static readonly grpc::Method<global::Lnrpc.NodeMetricsRequest, global::Lnrpc.NodeMetricsResponse> __Method_GetNodeMetrics = new grpc::Method<global::Lnrpc.NodeMetricsRequest, global::Lnrpc.NodeMetricsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetNodeMetrics",
        __Marshaller_lnrpc_NodeMetricsRequest,
        __Marshaller_lnrpc_NodeMetricsResponse);

    static readonly grpc::Method<global::Lnrpc.ChanInfoRequest, global::Lnrpc.ChannelEdge> __Method_GetChanInfo = new grpc::Method<global::Lnrpc.ChanInfoRequest, global::Lnrpc.ChannelEdge>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetChanInfo",
        __Marshaller_lnrpc_ChanInfoRequest,
        __Marshaller_lnrpc_ChannelEdge);

    static readonly grpc::Method<global::Lnrpc.NodeInfoRequest, global::Lnrpc.NodeInfo> __Method_GetNodeInfo = new grpc::Method<global::Lnrpc.NodeInfoRequest, global::Lnrpc.NodeInfo>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetNodeInfo",
        __Marshaller_lnrpc_NodeInfoRequest,
        __Marshaller_lnrpc_NodeInfo);

    static readonly grpc::Method<global::Lnrpc.QueryRoutesRequest, global::Lnrpc.QueryRoutesResponse> __Method_QueryRoutes = new grpc::Method<global::Lnrpc.QueryRoutesRequest, global::Lnrpc.QueryRoutesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "QueryRoutes",
        __Marshaller_lnrpc_QueryRoutesRequest,
        __Marshaller_lnrpc_QueryRoutesResponse);

    static readonly grpc::Method<global::Lnrpc.NetworkInfoRequest, global::Lnrpc.NetworkInfo> __Method_GetNetworkInfo = new grpc::Method<global::Lnrpc.NetworkInfoRequest, global::Lnrpc.NetworkInfo>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetNetworkInfo",
        __Marshaller_lnrpc_NetworkInfoRequest,
        __Marshaller_lnrpc_NetworkInfo);

    static readonly grpc::Method<global::Lnrpc.StopRequest, global::Lnrpc.StopResponse> __Method_StopDaemon = new grpc::Method<global::Lnrpc.StopRequest, global::Lnrpc.StopResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "StopDaemon",
        __Marshaller_lnrpc_StopRequest,
        __Marshaller_lnrpc_StopResponse);

    static readonly grpc::Method<global::Lnrpc.GraphTopologySubscription, global::Lnrpc.GraphTopologyUpdate> __Method_SubscribeChannelGraph = new grpc::Method<global::Lnrpc.GraphTopologySubscription, global::Lnrpc.GraphTopologyUpdate>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribeChannelGraph",
        __Marshaller_lnrpc_GraphTopologySubscription,
        __Marshaller_lnrpc_GraphTopologyUpdate);

    static readonly grpc::Method<global::Lnrpc.DebugLevelRequest, global::Lnrpc.DebugLevelResponse> __Method_DebugLevel = new grpc::Method<global::Lnrpc.DebugLevelRequest, global::Lnrpc.DebugLevelResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DebugLevel",
        __Marshaller_lnrpc_DebugLevelRequest,
        __Marshaller_lnrpc_DebugLevelResponse);

    static readonly grpc::Method<global::Lnrpc.FeeReportRequest, global::Lnrpc.FeeReportResponse> __Method_FeeReport = new grpc::Method<global::Lnrpc.FeeReportRequest, global::Lnrpc.FeeReportResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "FeeReport",
        __Marshaller_lnrpc_FeeReportRequest,
        __Marshaller_lnrpc_FeeReportResponse);

    static readonly grpc::Method<global::Lnrpc.PolicyUpdateRequest, global::Lnrpc.PolicyUpdateResponse> __Method_UpdateChannelPolicy = new grpc::Method<global::Lnrpc.PolicyUpdateRequest, global::Lnrpc.PolicyUpdateResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "UpdateChannelPolicy",
        __Marshaller_lnrpc_PolicyUpdateRequest,
        __Marshaller_lnrpc_PolicyUpdateResponse);

    static readonly grpc::Method<global::Lnrpc.ForwardingHistoryRequest, global::Lnrpc.ForwardingHistoryResponse> __Method_ForwardingHistory = new grpc::Method<global::Lnrpc.ForwardingHistoryRequest, global::Lnrpc.ForwardingHistoryResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ForwardingHistory",
        __Marshaller_lnrpc_ForwardingHistoryRequest,
        __Marshaller_lnrpc_ForwardingHistoryResponse);

    static readonly grpc::Method<global::Lnrpc.ExportChannelBackupRequest, global::Lnrpc.ChannelBackup> __Method_ExportChannelBackup = new grpc::Method<global::Lnrpc.ExportChannelBackupRequest, global::Lnrpc.ChannelBackup>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ExportChannelBackup",
        __Marshaller_lnrpc_ExportChannelBackupRequest,
        __Marshaller_lnrpc_ChannelBackup);

    static readonly grpc::Method<global::Lnrpc.ChanBackupExportRequest, global::Lnrpc.ChanBackupSnapshot> __Method_ExportAllChannelBackups = new grpc::Method<global::Lnrpc.ChanBackupExportRequest, global::Lnrpc.ChanBackupSnapshot>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ExportAllChannelBackups",
        __Marshaller_lnrpc_ChanBackupExportRequest,
        __Marshaller_lnrpc_ChanBackupSnapshot);

    static readonly grpc::Method<global::Lnrpc.ChanBackupSnapshot, global::Lnrpc.VerifyChanBackupResponse> __Method_VerifyChanBackup = new grpc::Method<global::Lnrpc.ChanBackupSnapshot, global::Lnrpc.VerifyChanBackupResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "VerifyChanBackup",
        __Marshaller_lnrpc_ChanBackupSnapshot,
        __Marshaller_lnrpc_VerifyChanBackupResponse);

    static readonly grpc::Method<global::Lnrpc.RestoreChanBackupRequest, global::Lnrpc.RestoreBackupResponse> __Method_RestoreChannelBackups = new grpc::Method<global::Lnrpc.RestoreChanBackupRequest, global::Lnrpc.RestoreBackupResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "RestoreChannelBackups",
        __Marshaller_lnrpc_RestoreChanBackupRequest,
        __Marshaller_lnrpc_RestoreBackupResponse);

    static readonly grpc::Method<global::Lnrpc.ChannelBackupSubscription, global::Lnrpc.ChanBackupSnapshot> __Method_SubscribeChannelBackups = new grpc::Method<global::Lnrpc.ChannelBackupSubscription, global::Lnrpc.ChanBackupSnapshot>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribeChannelBackups",
        __Marshaller_lnrpc_ChannelBackupSubscription,
        __Marshaller_lnrpc_ChanBackupSnapshot);

    static readonly grpc::Method<global::Lnrpc.BakeMacaroonRequest, global::Lnrpc.BakeMacaroonResponse> __Method_BakeMacaroon = new grpc::Method<global::Lnrpc.BakeMacaroonRequest, global::Lnrpc.BakeMacaroonResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "BakeMacaroon",
        __Marshaller_lnrpc_BakeMacaroonRequest,
        __Marshaller_lnrpc_BakeMacaroonResponse);

    static readonly grpc::Method<global::Lnrpc.ListMacaroonIDsRequest, global::Lnrpc.ListMacaroonIDsResponse> __Method_ListMacaroonIDs = new grpc::Method<global::Lnrpc.ListMacaroonIDsRequest, global::Lnrpc.ListMacaroonIDsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListMacaroonIDs",
        __Marshaller_lnrpc_ListMacaroonIDsRequest,
        __Marshaller_lnrpc_ListMacaroonIDsResponse);

    static readonly grpc::Method<global::Lnrpc.DeleteMacaroonIDRequest, global::Lnrpc.DeleteMacaroonIDResponse> __Method_DeleteMacaroonID = new grpc::Method<global::Lnrpc.DeleteMacaroonIDRequest, global::Lnrpc.DeleteMacaroonIDResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeleteMacaroonID",
        __Marshaller_lnrpc_DeleteMacaroonIDRequest,
        __Marshaller_lnrpc_DeleteMacaroonIDResponse);

    static readonly grpc::Method<global::Lnrpc.ListPermissionsRequest, global::Lnrpc.ListPermissionsResponse> __Method_ListPermissions = new grpc::Method<global::Lnrpc.ListPermissionsRequest, global::Lnrpc.ListPermissionsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListPermissions",
        __Marshaller_lnrpc_ListPermissionsRequest,
        __Marshaller_lnrpc_ListPermissionsResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Lnrpc.RpcReflection.Descriptor.Services[0]; }
    }

    /// <summary>Client for Lightning</summary>
    public partial class LightningClient : grpc::ClientBase<LightningClient>
    {
      /// <summary>Creates a new client for Lightning</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public LightningClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for Lightning that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public LightningClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected LightningClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected LightningClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      /// lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.WalletBalanceResponse WalletBalance(global::Lnrpc.WalletBalanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return WalletBalance(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.WalletBalanceResponse WalletBalance(global::Lnrpc.WalletBalanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_WalletBalance, null, options, request);
      }
      /// <summary>
      /// lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.WalletBalanceResponse> WalletBalanceAsync(global::Lnrpc.WalletBalanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return WalletBalanceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.WalletBalanceResponse> WalletBalanceAsync(global::Lnrpc.WalletBalanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_WalletBalance, null, options, request);
      }
      /// <summary>
      /// lncli: `channelbalance`
      ///ChannelBalance returns a report on the total funds across all open channels,
      ///categorized in local/remote, pending local/remote and unsettled local/remote
      ///balances.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelBalanceResponse ChannelBalance(global::Lnrpc.ChannelBalanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ChannelBalance(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `channelbalance`
      ///ChannelBalance returns a report on the total funds across all open channels,
      ///categorized in local/remote, pending local/remote and unsettled local/remote
      ///balances.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelBalanceResponse ChannelBalance(global::Lnrpc.ChannelBalanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ChannelBalance, null, options, request);
      }
      /// <summary>
      /// lncli: `channelbalance`
      ///ChannelBalance returns a report on the total funds across all open channels,
      ///categorized in local/remote, pending local/remote and unsettled local/remote
      ///balances.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelBalanceResponse> ChannelBalanceAsync(global::Lnrpc.ChannelBalanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ChannelBalanceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `channelbalance`
      ///ChannelBalance returns a report on the total funds across all open channels,
      ///categorized in local/remote, pending local/remote and unsettled local/remote
      ///balances.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelBalanceResponse> ChannelBalanceAsync(global::Lnrpc.ChannelBalanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ChannelBalance, null, options, request);
      }
      /// <summary>
      /// lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.TransactionDetails GetTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTransactions(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.TransactionDetails GetTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetTransactions, null, options, request);
      }
      /// <summary>
      /// lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.TransactionDetails> GetTransactionsAsync(global::Lnrpc.GetTransactionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetTransactionsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.TransactionDetails> GetTransactionsAsync(global::Lnrpc.GetTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetTransactions, null, options, request);
      }
      /// <summary>
      /// lncli: `estimatefee`
      ///EstimateFee asks the chain backend to estimate the fee rate and total fees
      ///for a transaction that pays to multiple specified outputs.
      ///
      ///When using REST, the `AddrToAmount` map type can be set by appending
      ///`&amp;AddrToAmount[&lt;address>]=&lt;amount_to_send>` to the URL. Unfortunately this
      ///map type doesn't appear in the REST API documentation because of a bug in
      ///the grpc-gateway library.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.EstimateFeeResponse EstimateFee(global::Lnrpc.EstimateFeeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EstimateFee(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `estimatefee`
      ///EstimateFee asks the chain backend to estimate the fee rate and total fees
      ///for a transaction that pays to multiple specified outputs.
      ///
      ///When using REST, the `AddrToAmount` map type can be set by appending
      ///`&amp;AddrToAmount[&lt;address>]=&lt;amount_to_send>` to the URL. Unfortunately this
      ///map type doesn't appear in the REST API documentation because of a bug in
      ///the grpc-gateway library.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.EstimateFeeResponse EstimateFee(global::Lnrpc.EstimateFeeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_EstimateFee, null, options, request);
      }
      /// <summary>
      /// lncli: `estimatefee`
      ///EstimateFee asks the chain backend to estimate the fee rate and total fees
      ///for a transaction that pays to multiple specified outputs.
      ///
      ///When using REST, the `AddrToAmount` map type can be set by appending
      ///`&amp;AddrToAmount[&lt;address>]=&lt;amount_to_send>` to the URL. Unfortunately this
      ///map type doesn't appear in the REST API documentation because of a bug in
      ///the grpc-gateway library.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.EstimateFeeResponse> EstimateFeeAsync(global::Lnrpc.EstimateFeeRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return EstimateFeeAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `estimatefee`
      ///EstimateFee asks the chain backend to estimate the fee rate and total fees
      ///for a transaction that pays to multiple specified outputs.
      ///
      ///When using REST, the `AddrToAmount` map type can be set by appending
      ///`&amp;AddrToAmount[&lt;address>]=&lt;amount_to_send>` to the URL. Unfortunately this
      ///map type doesn't appear in the REST API documentation because of a bug in
      ///the grpc-gateway library.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.EstimateFeeResponse> EstimateFeeAsync(global::Lnrpc.EstimateFeeRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_EstimateFee, null, options, request);
      }
      /// <summary>
      /// lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_vbyte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendCoinsResponse SendCoins(global::Lnrpc.SendCoinsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendCoins(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_vbyte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendCoinsResponse SendCoins(global::Lnrpc.SendCoinsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendCoins, null, options, request);
      }
      /// <summary>
      /// lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_vbyte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendCoinsResponse> SendCoinsAsync(global::Lnrpc.SendCoinsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendCoinsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_vbyte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendCoinsResponse> SendCoinsAsync(global::Lnrpc.SendCoinsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendCoins, null, options, request);
      }
      /// <summary>
      /// lncli: `listunspent`
      ///Deprecated, use walletrpc.ListUnspent instead.
      ///
      ///ListUnspent returns a list of all utxos spendable by the wallet with a
      ///number of confirmations between the specified minimum and maximum.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListUnspentResponse ListUnspent(global::Lnrpc.ListUnspentRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListUnspent(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listunspent`
      ///Deprecated, use walletrpc.ListUnspent instead.
      ///
      ///ListUnspent returns a list of all utxos spendable by the wallet with a
      ///number of confirmations between the specified minimum and maximum.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListUnspentResponse ListUnspent(global::Lnrpc.ListUnspentRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListUnspent, null, options, request);
      }
      /// <summary>
      /// lncli: `listunspent`
      ///Deprecated, use walletrpc.ListUnspent instead.
      ///
      ///ListUnspent returns a list of all utxos spendable by the wallet with a
      ///number of confirmations between the specified minimum and maximum.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListUnspentResponse> ListUnspentAsync(global::Lnrpc.ListUnspentRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListUnspentAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listunspent`
      ///Deprecated, use walletrpc.ListUnspent instead.
      ///
      ///ListUnspent returns a list of all utxos spendable by the wallet with a
      ///number of confirmations between the specified minimum and maximum.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListUnspentResponse> ListUnspentAsync(global::Lnrpc.ListUnspentRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListUnspent, null, options, request);
      }
      /// <summary>
      ///
      ///SubscribeTransactions creates a uni-directional stream from the server to
      ///the client in which any newly discovered transactions relevant to the
      ///wallet are sent over.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.Transaction> SubscribeTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubscribeTransactions(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SubscribeTransactions creates a uni-directional stream from the server to
      ///the client in which any newly discovered transactions relevant to the
      ///wallet are sent over.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.Transaction> SubscribeTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribeTransactions, null, options, request);
      }
      /// <summary>
      /// lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendManyResponse SendMany(global::Lnrpc.SendManyRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendMany(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendManyResponse SendMany(global::Lnrpc.SendManyRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendMany, null, options, request);
      }
      /// <summary>
      /// lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendManyResponse> SendManyAsync(global::Lnrpc.SendManyRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendManyAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendManyResponse> SendManyAsync(global::Lnrpc.SendManyRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendMany, null, options, request);
      }
      /// <summary>
      /// lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NewAddressResponse NewAddress(global::Lnrpc.NewAddressRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return NewAddress(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NewAddressResponse NewAddress(global::Lnrpc.NewAddressRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_NewAddress, null, options, request);
      }
      /// <summary>
      /// lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NewAddressResponse> NewAddressAsync(global::Lnrpc.NewAddressRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return NewAddressAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NewAddressResponse> NewAddressAsync(global::Lnrpc.NewAddressRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_NewAddress, null, options, request);
      }
      /// <summary>
      /// lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SignMessageResponse SignMessage(global::Lnrpc.SignMessageRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SignMessage(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SignMessageResponse SignMessage(global::Lnrpc.SignMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SignMessage, null, options, request);
      }
      /// <summary>
      /// lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SignMessageResponse> SignMessageAsync(global::Lnrpc.SignMessageRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SignMessageAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SignMessageResponse> SignMessageAsync(global::Lnrpc.SignMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SignMessage, null, options, request);
      }
      /// <summary>
      /// lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.VerifyMessageResponse VerifyMessage(global::Lnrpc.VerifyMessageRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return VerifyMessage(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.VerifyMessageResponse VerifyMessage(global::Lnrpc.VerifyMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_VerifyMessage, null, options, request);
      }
      /// <summary>
      /// lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.VerifyMessageResponse> VerifyMessageAsync(global::Lnrpc.VerifyMessageRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return VerifyMessageAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.VerifyMessageResponse> VerifyMessageAsync(global::Lnrpc.VerifyMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_VerifyMessage, null, options, request);
      }
      /// <summary>
      /// lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ConnectPeerResponse ConnectPeer(global::Lnrpc.ConnectPeerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ConnectPeer(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ConnectPeerResponse ConnectPeer(global::Lnrpc.ConnectPeerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ConnectPeer, null, options, request);
      }
      /// <summary>
      /// lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ConnectPeerResponse> ConnectPeerAsync(global::Lnrpc.ConnectPeerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ConnectPeerAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ConnectPeerResponse> ConnectPeerAsync(global::Lnrpc.ConnectPeerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ConnectPeer, null, options, request);
      }
      /// <summary>
      /// lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DisconnectPeerResponse DisconnectPeer(global::Lnrpc.DisconnectPeerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DisconnectPeer(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DisconnectPeerResponse DisconnectPeer(global::Lnrpc.DisconnectPeerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DisconnectPeer, null, options, request);
      }
      /// <summary>
      /// lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DisconnectPeerResponse> DisconnectPeerAsync(global::Lnrpc.DisconnectPeerRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DisconnectPeerAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DisconnectPeerResponse> DisconnectPeerAsync(global::Lnrpc.DisconnectPeerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DisconnectPeer, null, options, request);
      }
      /// <summary>
      /// lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPeersResponse ListPeers(global::Lnrpc.ListPeersRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListPeers(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPeersResponse ListPeers(global::Lnrpc.ListPeersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListPeers, null, options, request);
      }
      /// <summary>
      /// lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPeersResponse> ListPeersAsync(global::Lnrpc.ListPeersRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListPeersAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPeersResponse> ListPeersAsync(global::Lnrpc.ListPeersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListPeers, null, options, request);
      }
      /// <summary>
      ///
      ///SubscribePeerEvents creates a uni-directional stream from the server to
      ///the client in which any events relevant to the state of peers are sent
      ///over. Events include peers going online and offline.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.PeerEvent> SubscribePeerEvents(global::Lnrpc.PeerEventSubscription request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubscribePeerEvents(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SubscribePeerEvents creates a uni-directional stream from the server to
      ///the client in which any events relevant to the state of peers are sent
      ///over. Events include peers going online and offline.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.PeerEvent> SubscribePeerEvents(global::Lnrpc.PeerEventSubscription request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribePeerEvents, null, options, request);
      }
      /// <summary>
      /// lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.GetInfoResponse GetInfo(global::Lnrpc.GetInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.GetInfoResponse GetInfo(global::Lnrpc.GetInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetInfo, null, options, request);
      }
      /// <summary>
      /// lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.GetInfoResponse> GetInfoAsync(global::Lnrpc.GetInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.GetInfoResponse> GetInfoAsync(global::Lnrpc.GetInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `getrecoveryinfo`
      ///GetRecoveryInfo returns information concerning the recovery mode including
      ///whether it's in a recovery mode, whether the recovery is finished, and the
      ///progress made so far.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.GetRecoveryInfoResponse GetRecoveryInfo(global::Lnrpc.GetRecoveryInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetRecoveryInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getrecoveryinfo`
      ///GetRecoveryInfo returns information concerning the recovery mode including
      ///whether it's in a recovery mode, whether the recovery is finished, and the
      ///progress made so far.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.GetRecoveryInfoResponse GetRecoveryInfo(global::Lnrpc.GetRecoveryInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetRecoveryInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `getrecoveryinfo`
      ///GetRecoveryInfo returns information concerning the recovery mode including
      ///whether it's in a recovery mode, whether the recovery is finished, and the
      ///progress made so far.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.GetRecoveryInfoResponse> GetRecoveryInfoAsync(global::Lnrpc.GetRecoveryInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetRecoveryInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getrecoveryinfo`
      ///GetRecoveryInfo returns information concerning the recovery mode including
      ///whether it's in a recovery mode, whether the recovery is finished, and the
      ///progress made so far.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.GetRecoveryInfoResponse> GetRecoveryInfoAsync(global::Lnrpc.GetRecoveryInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetRecoveryInfo, null, options, request);
      }
      /// <summary>
      /// lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PendingChannelsResponse PendingChannels(global::Lnrpc.PendingChannelsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PendingChannels(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PendingChannelsResponse PendingChannels(global::Lnrpc.PendingChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PendingChannels, null, options, request);
      }
      /// <summary>
      /// lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PendingChannelsResponse> PendingChannelsAsync(global::Lnrpc.PendingChannelsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PendingChannelsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PendingChannelsResponse> PendingChannelsAsync(global::Lnrpc.PendingChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PendingChannels, null, options, request);
      }
      /// <summary>
      /// lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListChannelsResponse ListChannels(global::Lnrpc.ListChannelsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListChannels(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListChannelsResponse ListChannels(global::Lnrpc.ListChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListChannels, null, options, request);
      }
      /// <summary>
      /// lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListChannelsResponse> ListChannelsAsync(global::Lnrpc.ListChannelsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListChannelsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListChannelsResponse> ListChannelsAsync(global::Lnrpc.ListChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListChannels, null, options, request);
      }
      /// <summary>
      ///
      ///SubscribeChannelEvents creates a uni-directional stream from the server to
      ///the client in which any updates relevant to the state of the channels are
      ///sent over. Events include new active channels, inactive channels, and closed
      ///channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.ChannelEventUpdate> SubscribeChannelEvents(global::Lnrpc.ChannelEventSubscription request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubscribeChannelEvents(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SubscribeChannelEvents creates a uni-directional stream from the server to
      ///the client in which any updates relevant to the state of the channels are
      ///sent over. Events include new active channels, inactive channels, and closed
      ///channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.ChannelEventUpdate> SubscribeChannelEvents(global::Lnrpc.ChannelEventSubscription request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribeChannelEvents, null, options, request);
      }
      /// <summary>
      /// lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ClosedChannelsResponse ClosedChannels(global::Lnrpc.ClosedChannelsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ClosedChannels(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ClosedChannelsResponse ClosedChannels(global::Lnrpc.ClosedChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ClosedChannels, null, options, request);
      }
      /// <summary>
      /// lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ClosedChannelsResponse> ClosedChannelsAsync(global::Lnrpc.ClosedChannelsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ClosedChannelsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ClosedChannelsResponse> ClosedChannelsAsync(global::Lnrpc.ClosedChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ClosedChannels, null, options, request);
      }
      /// <summary>
      ///
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelPoint OpenChannelSync(global::Lnrpc.OpenChannelRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return OpenChannelSync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelPoint OpenChannelSync(global::Lnrpc.OpenChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_OpenChannelSync, null, options, request);
      }
      /// <summary>
      ///
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelPoint> OpenChannelSyncAsync(global::Lnrpc.OpenChannelRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return OpenChannelSyncAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelPoint> OpenChannelSyncAsync(global::Lnrpc.OpenChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_OpenChannelSync, null, options, request);
      }
      /// <summary>
      /// lncli: `openchannel`
      ///OpenChannel attempts to open a singly funded channel specified in the
      ///request to a remote peer. Users are able to specify a target number of
      ///blocks that the funding transaction should be confirmed in, or a manual fee
      ///rate to us for the funding transaction. If neither are specified, then a
      ///lax block confirmation target is used. Each OpenStatusUpdate will return
      ///the pending channel ID of the in-progress channel. Depending on the
      ///arguments specified in the OpenChannelRequest, this pending channel ID can
      ///then be used to manually progress the channel funding flow.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.OpenStatusUpdate> OpenChannel(global::Lnrpc.OpenChannelRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return OpenChannel(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `openchannel`
      ///OpenChannel attempts to open a singly funded channel specified in the
      ///request to a remote peer. Users are able to specify a target number of
      ///blocks that the funding transaction should be confirmed in, or a manual fee
      ///rate to us for the funding transaction. If neither are specified, then a
      ///lax block confirmation target is used. Each OpenStatusUpdate will return
      ///the pending channel ID of the in-progress channel. Depending on the
      ///arguments specified in the OpenChannelRequest, this pending channel ID can
      ///then be used to manually progress the channel funding flow.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.OpenStatusUpdate> OpenChannel(global::Lnrpc.OpenChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_OpenChannel, null, options, request);
      }
      /// <summary>
      ///
      ///FundingStateStep is an advanced funding related call that allows the caller
      ///to either execute some preparatory steps for a funding workflow, or
      ///manually progress a funding workflow. The primary way a funding flow is
      ///identified is via its pending channel ID. As an example, this method can be
      ///used to specify that we're expecting a funding flow for a particular
      ///pending channel ID, for which we need to use specific parameters.
      ///Alternatively, this can be used to interactively drive PSBT signing for
      ///funding for partially complete funding transactions.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.FundingStateStepResp FundingStateStep(global::Lnrpc.FundingTransitionMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FundingStateStep(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///FundingStateStep is an advanced funding related call that allows the caller
      ///to either execute some preparatory steps for a funding workflow, or
      ///manually progress a funding workflow. The primary way a funding flow is
      ///identified is via its pending channel ID. As an example, this method can be
      ///used to specify that we're expecting a funding flow for a particular
      ///pending channel ID, for which we need to use specific parameters.
      ///Alternatively, this can be used to interactively drive PSBT signing for
      ///funding for partially complete funding transactions.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.FundingStateStepResp FundingStateStep(global::Lnrpc.FundingTransitionMsg request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_FundingStateStep, null, options, request);
      }
      /// <summary>
      ///
      ///FundingStateStep is an advanced funding related call that allows the caller
      ///to either execute some preparatory steps for a funding workflow, or
      ///manually progress a funding workflow. The primary way a funding flow is
      ///identified is via its pending channel ID. As an example, this method can be
      ///used to specify that we're expecting a funding flow for a particular
      ///pending channel ID, for which we need to use specific parameters.
      ///Alternatively, this can be used to interactively drive PSBT signing for
      ///funding for partially complete funding transactions.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.FundingStateStepResp> FundingStateStepAsync(global::Lnrpc.FundingTransitionMsg request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FundingStateStepAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///FundingStateStep is an advanced funding related call that allows the caller
      ///to either execute some preparatory steps for a funding workflow, or
      ///manually progress a funding workflow. The primary way a funding flow is
      ///identified is via its pending channel ID. As an example, this method can be
      ///used to specify that we're expecting a funding flow for a particular
      ///pending channel ID, for which we need to use specific parameters.
      ///Alternatively, this can be used to interactively drive PSBT signing for
      ///funding for partially complete funding transactions.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.FundingStateStepResp> FundingStateStepAsync(global::Lnrpc.FundingTransitionMsg request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_FundingStateStep, null, options, request);
      }
      /// <summary>
      ///
      ///ChannelAcceptor dispatches a bi-directional streaming RPC in which
      ///OpenChannel requests are sent to the client and the client responds with
      ///a boolean that tells LND whether or not to accept the channel. This allows
      ///node operators to specify their own criteria for accepting inbound channels
      ///through a single persistent connection.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.ChannelAcceptResponse, global::Lnrpc.ChannelAcceptRequest> ChannelAcceptor(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ChannelAcceptor(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///ChannelAcceptor dispatches a bi-directional streaming RPC in which
      ///OpenChannel requests are sent to the client and the client responds with
      ///a boolean that tells LND whether or not to accept the channel. This allows
      ///node operators to specify their own criteria for accepting inbound channels
      ///through a single persistent connection.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.ChannelAcceptResponse, global::Lnrpc.ChannelAcceptRequest> ChannelAcceptor(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_ChannelAcceptor, null, options);
      }
      /// <summary>
      /// lncli: `closechannel`
      ///CloseChannel attempts to close an active channel identified by its channel
      ///outpoint (ChannelPoint). The actions of this method can additionally be
      ///augmented to attempt a force close after a timeout period in the case of an
      ///inactive peer. If a non-force close (cooperative closure) is requested,
      ///then the user can specify either a target number of blocks until the
      ///closure transaction is confirmed, or a manual fee rate. If neither are
      ///specified, then a default lax, block confirmation target is used.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.CloseStatusUpdate> CloseChannel(global::Lnrpc.CloseChannelRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CloseChannel(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `closechannel`
      ///CloseChannel attempts to close an active channel identified by its channel
      ///outpoint (ChannelPoint). The actions of this method can additionally be
      ///augmented to attempt a force close after a timeout period in the case of an
      ///inactive peer. If a non-force close (cooperative closure) is requested,
      ///then the user can specify either a target number of blocks until the
      ///closure transaction is confirmed, or a manual fee rate. If neither are
      ///specified, then a default lax, block confirmation target is used.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.CloseStatusUpdate> CloseChannel(global::Lnrpc.CloseChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_CloseChannel, null, options, request);
      }
      /// <summary>
      /// lncli: `abandonchannel`
      ///AbandonChannel removes all channel state from the database except for a
      ///close summary. This method can be used to get rid of permanently unusable
      ///channels due to bugs fixed in newer versions of lnd. This method can also be
      ///used to remove externally funded channels where the funding transaction was
      ///never broadcast. Only available for non-externally funded channels in dev
      ///build.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.AbandonChannelResponse AbandonChannel(global::Lnrpc.AbandonChannelRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AbandonChannel(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `abandonchannel`
      ///AbandonChannel removes all channel state from the database except for a
      ///close summary. This method can be used to get rid of permanently unusable
      ///channels due to bugs fixed in newer versions of lnd. This method can also be
      ///used to remove externally funded channels where the funding transaction was
      ///never broadcast. Only available for non-externally funded channels in dev
      ///build.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.AbandonChannelResponse AbandonChannel(global::Lnrpc.AbandonChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_AbandonChannel, null, options, request);
      }
      /// <summary>
      /// lncli: `abandonchannel`
      ///AbandonChannel removes all channel state from the database except for a
      ///close summary. This method can be used to get rid of permanently unusable
      ///channels due to bugs fixed in newer versions of lnd. This method can also be
      ///used to remove externally funded channels where the funding transaction was
      ///never broadcast. Only available for non-externally funded channels in dev
      ///build.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.AbandonChannelResponse> AbandonChannelAsync(global::Lnrpc.AbandonChannelRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AbandonChannelAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `abandonchannel`
      ///AbandonChannel removes all channel state from the database except for a
      ///close summary. This method can be used to get rid of permanently unusable
      ///channels due to bugs fixed in newer versions of lnd. This method can also be
      ///used to remove externally funded channels where the funding transaction was
      ///never broadcast. Only available for non-externally funded channels in dev
      ///build.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.AbandonChannelResponse> AbandonChannelAsync(global::Lnrpc.AbandonChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_AbandonChannel, null, options, request);
      }
      /// <summary>
      /// lncli: `sendpayment`
      ///Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
      ///bi-directional streaming RPC for sending payments through the Lightning
      ///Network. A single RPC invocation creates a persistent bi-directional
      ///stream allowing clients to rapidly send payments through the Lightning
      ///Network with a single persistent connection.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse> SendPayment(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendPayment(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `sendpayment`
      ///Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
      ///bi-directional streaming RPC for sending payments through the Lightning
      ///Network. A single RPC invocation creates a persistent bi-directional
      ///stream allowing clients to rapidly send payments through the Lightning
      ///Network with a single persistent connection.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse> SendPayment(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_SendPayment, null, options);
      }
      /// <summary>
      ///
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendResponse SendPaymentSync(global::Lnrpc.SendRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendPaymentSync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendResponse SendPaymentSync(global::Lnrpc.SendRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendPaymentSync, null, options, request);
      }
      /// <summary>
      ///
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendResponse> SendPaymentSyncAsync(global::Lnrpc.SendRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendPaymentSyncAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendResponse> SendPaymentSyncAsync(global::Lnrpc.SendRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendPaymentSync, null, options, request);
      }
      /// <summary>
      /// lncli: `sendtoroute`
      ///Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
      ///streaming RPC for sending payment through the Lightning Network. This
      ///method differs from SendPayment in that it allows users to specify a full
      ///route manually. This can be used for things like rebalancing, and atomic
      ///swaps.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse> SendToRoute(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendToRoute(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `sendtoroute`
      ///Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
      ///streaming RPC for sending payment through the Lightning Network. This
      ///method differs from SendPayment in that it allows users to specify a full
      ///route manually. This can be used for things like rebalancing, and atomic
      ///swaps.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse> SendToRoute(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_SendToRoute, null, options);
      }
      /// <summary>
      ///
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendResponse SendToRouteSync(global::Lnrpc.SendToRouteRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendToRouteSync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendResponse SendToRouteSync(global::Lnrpc.SendToRouteRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendToRouteSync, null, options, request);
      }
      /// <summary>
      ///
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendResponse> SendToRouteSyncAsync(global::Lnrpc.SendToRouteRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendToRouteSyncAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendResponse> SendToRouteSyncAsync(global::Lnrpc.SendToRouteRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendToRouteSync, null, options, request);
      }
      /// <summary>
      /// lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.AddInvoiceResponse AddInvoice(global::Lnrpc.Invoice request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AddInvoice(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.AddInvoiceResponse AddInvoice(global::Lnrpc.Invoice request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_AddInvoice, null, options, request);
      }
      /// <summary>
      /// lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.AddInvoiceResponse> AddInvoiceAsync(global::Lnrpc.Invoice request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return AddInvoiceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.AddInvoiceResponse> AddInvoiceAsync(global::Lnrpc.Invoice request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_AddInvoice, null, options, request);
      }
      /// <summary>
      /// lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored. It has full support for
      ///paginated responses, allowing users to query for specific invoices through
      ///their add_index. This can be done by using either the first_index_offset or
      ///last_index_offset fields included in the response as the index_offset of the
      ///next request. By default, the first 100 invoices created will be returned.
      ///Backwards pagination is also supported through the Reversed flag.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListInvoiceResponse ListInvoices(global::Lnrpc.ListInvoiceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListInvoices(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored. It has full support for
      ///paginated responses, allowing users to query for specific invoices through
      ///their add_index. This can be done by using either the first_index_offset or
      ///last_index_offset fields included in the response as the index_offset of the
      ///next request. By default, the first 100 invoices created will be returned.
      ///Backwards pagination is also supported through the Reversed flag.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListInvoiceResponse ListInvoices(global::Lnrpc.ListInvoiceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListInvoices, null, options, request);
      }
      /// <summary>
      /// lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored. It has full support for
      ///paginated responses, allowing users to query for specific invoices through
      ///their add_index. This can be done by using either the first_index_offset or
      ///last_index_offset fields included in the response as the index_offset of the
      ///next request. By default, the first 100 invoices created will be returned.
      ///Backwards pagination is also supported through the Reversed flag.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListInvoiceResponse> ListInvoicesAsync(global::Lnrpc.ListInvoiceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListInvoicesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored. It has full support for
      ///paginated responses, allowing users to query for specific invoices through
      ///their add_index. This can be done by using either the first_index_offset or
      ///last_index_offset fields included in the response as the index_offset of the
      ///next request. By default, the first 100 invoices created will be returned.
      ///Backwards pagination is also supported through the Reversed flag.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListInvoiceResponse> ListInvoicesAsync(global::Lnrpc.ListInvoiceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListInvoices, null, options, request);
      }
      /// <summary>
      /// lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.Invoice LookupInvoice(global::Lnrpc.PaymentHash request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return LookupInvoice(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.Invoice LookupInvoice(global::Lnrpc.PaymentHash request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_LookupInvoice, null, options, request);
      }
      /// <summary>
      /// lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.Invoice> LookupInvoiceAsync(global::Lnrpc.PaymentHash request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return LookupInvoiceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.Invoice> LookupInvoiceAsync(global::Lnrpc.PaymentHash request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_LookupInvoice, null, options, request);
      }
      /// <summary>
      ///
      ///SubscribeInvoices returns a uni-directional stream (server -> client) for
      ///notifying the client of newly added/settled invoices. The caller can
      ///optionally specify the add_index and/or the settle_index. If the add_index
      ///is specified, then we'll first start by sending add invoice events for all
      ///invoices with an add_index greater than the specified value. If the
      ///settle_index is specified, the next, we'll send out all settle events for
      ///invoices with a settle_index greater than the specified value. One or both
      ///of these fields can be set. If no fields are set, then we'll only send out
      ///the latest add/settle events.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.Invoice> SubscribeInvoices(global::Lnrpc.InvoiceSubscription request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubscribeInvoices(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SubscribeInvoices returns a uni-directional stream (server -> client) for
      ///notifying the client of newly added/settled invoices. The caller can
      ///optionally specify the add_index and/or the settle_index. If the add_index
      ///is specified, then we'll first start by sending add invoice events for all
      ///invoices with an add_index greater than the specified value. If the
      ///settle_index is specified, the next, we'll send out all settle events for
      ///invoices with a settle_index greater than the specified value. One or both
      ///of these fields can be set. If no fields are set, then we'll only send out
      ///the latest add/settle events.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.Invoice> SubscribeInvoices(global::Lnrpc.InvoiceSubscription request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribeInvoices, null, options, request);
      }
      /// <summary>
      /// lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PayReq DecodePayReq(global::Lnrpc.PayReqString request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DecodePayReq(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PayReq DecodePayReq(global::Lnrpc.PayReqString request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DecodePayReq, null, options, request);
      }
      /// <summary>
      /// lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PayReq> DecodePayReqAsync(global::Lnrpc.PayReqString request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DecodePayReqAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PayReq> DecodePayReqAsync(global::Lnrpc.PayReqString request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DecodePayReq, null, options, request);
      }
      /// <summary>
      /// lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPaymentsResponse ListPayments(global::Lnrpc.ListPaymentsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListPayments(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPaymentsResponse ListPayments(global::Lnrpc.ListPaymentsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListPayments, null, options, request);
      }
      /// <summary>
      /// lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPaymentsResponse> ListPaymentsAsync(global::Lnrpc.ListPaymentsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListPaymentsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPaymentsResponse> ListPaymentsAsync(global::Lnrpc.ListPaymentsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListPayments, null, options, request);
      }
      /// <summary>
      ///
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DeleteAllPaymentsResponse DeleteAllPayments(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteAllPayments(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DeleteAllPaymentsResponse DeleteAllPayments(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeleteAllPayments, null, options, request);
      }
      /// <summary>
      ///
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DeleteAllPaymentsResponse> DeleteAllPaymentsAsync(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteAllPaymentsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DeleteAllPaymentsResponse> DeleteAllPaymentsAsync(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeleteAllPayments, null, options, request);
      }
      /// <summary>
      /// lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves. As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelGraph DescribeGraph(global::Lnrpc.ChannelGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DescribeGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves. As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelGraph DescribeGraph(global::Lnrpc.ChannelGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DescribeGraph, null, options, request);
      }
      /// <summary>
      /// lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves. As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelGraph> DescribeGraphAsync(global::Lnrpc.ChannelGraphRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DescribeGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves. As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelGraph> DescribeGraphAsync(global::Lnrpc.ChannelGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DescribeGraph, null, options, request);
      }
      /// <summary>
      /// lncli: `getnodemetrics`
      ///GetNodeMetrics returns node metrics calculated from the graph. Currently
      ///the only supported metric is betweenness centrality of individual nodes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NodeMetricsResponse GetNodeMetrics(global::Lnrpc.NodeMetricsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetNodeMetrics(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getnodemetrics`
      ///GetNodeMetrics returns node metrics calculated from the graph. Currently
      ///the only supported metric is betweenness centrality of individual nodes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NodeMetricsResponse GetNodeMetrics(global::Lnrpc.NodeMetricsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetNodeMetrics, null, options, request);
      }
      /// <summary>
      /// lncli: `getnodemetrics`
      ///GetNodeMetrics returns node metrics calculated from the graph. Currently
      ///the only supported metric is betweenness centrality of individual nodes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NodeMetricsResponse> GetNodeMetricsAsync(global::Lnrpc.NodeMetricsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetNodeMetricsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getnodemetrics`
      ///GetNodeMetrics returns node metrics calculated from the graph. Currently
      ///the only supported metric is betweenness centrality of individual nodes.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NodeMetricsResponse> GetNodeMetricsAsync(global::Lnrpc.NodeMetricsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetNodeMetrics, null, options, request);
      }
      /// <summary>
      /// lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelEdge GetChanInfo(global::Lnrpc.ChanInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetChanInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelEdge GetChanInfo(global::Lnrpc.ChanInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetChanInfo, null, options, request);
      }
      /// <summary>
      /// lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelEdge> GetChanInfoAsync(global::Lnrpc.ChanInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetChanInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelEdge> GetChanInfoAsync(global::Lnrpc.ChanInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetChanInfo, null, options, request);
      }
      /// <summary>
      /// lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NodeInfo GetNodeInfo(global::Lnrpc.NodeInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetNodeInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NodeInfo GetNodeInfo(global::Lnrpc.NodeInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetNodeInfo, null, options, request);
      }
      /// <summary>
      /// lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NodeInfo> GetNodeInfoAsync(global::Lnrpc.NodeInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetNodeInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NodeInfo> GetNodeInfoAsync(global::Lnrpc.NodeInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetNodeInfo, null, options, request);
      }
      /// <summary>
      /// lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The returned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      ///
      ///When using REST, the `dest_custom_records` map type can be set by appending
      ///`&amp;dest_custom_records[&lt;record_number>]=&lt;record_data_base64_url_encoded>`
      ///to the URL. Unfortunately this map type doesn't appear in the REST API
      ///documentation because of a bug in the grpc-gateway library.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.QueryRoutesResponse QueryRoutes(global::Lnrpc.QueryRoutesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return QueryRoutes(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The returned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      ///
      ///When using REST, the `dest_custom_records` map type can be set by appending
      ///`&amp;dest_custom_records[&lt;record_number>]=&lt;record_data_base64_url_encoded>`
      ///to the URL. Unfortunately this map type doesn't appear in the REST API
      ///documentation because of a bug in the grpc-gateway library.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.QueryRoutesResponse QueryRoutes(global::Lnrpc.QueryRoutesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_QueryRoutes, null, options, request);
      }
      /// <summary>
      /// lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The returned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      ///
      ///When using REST, the `dest_custom_records` map type can be set by appending
      ///`&amp;dest_custom_records[&lt;record_number>]=&lt;record_data_base64_url_encoded>`
      ///to the URL. Unfortunately this map type doesn't appear in the REST API
      ///documentation because of a bug in the grpc-gateway library.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.QueryRoutesResponse> QueryRoutesAsync(global::Lnrpc.QueryRoutesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return QueryRoutesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The returned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      ///
      ///When using REST, the `dest_custom_records` map type can be set by appending
      ///`&amp;dest_custom_records[&lt;record_number>]=&lt;record_data_base64_url_encoded>`
      ///to the URL. Unfortunately this map type doesn't appear in the REST API
      ///documentation because of a bug in the grpc-gateway library.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.QueryRoutesResponse> QueryRoutesAsync(global::Lnrpc.QueryRoutesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_QueryRoutes, null, options, request);
      }
      /// <summary>
      /// lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NetworkInfo GetNetworkInfo(global::Lnrpc.NetworkInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetNetworkInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NetworkInfo GetNetworkInfo(global::Lnrpc.NetworkInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetNetworkInfo, null, options, request);
      }
      /// <summary>
      /// lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NetworkInfo> GetNetworkInfoAsync(global::Lnrpc.NetworkInfoRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetNetworkInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NetworkInfo> GetNetworkInfoAsync(global::Lnrpc.NetworkInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetNetworkInfo, null, options, request);
      }
      /// <summary>
      /// lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.StopResponse StopDaemon(global::Lnrpc.StopRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return StopDaemon(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.StopResponse StopDaemon(global::Lnrpc.StopRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_StopDaemon, null, options, request);
      }
      /// <summary>
      /// lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.StopResponse> StopDaemonAsync(global::Lnrpc.StopRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return StopDaemonAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.StopResponse> StopDaemonAsync(global::Lnrpc.StopRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_StopDaemon, null, options, request);
      }
      /// <summary>
      ///
      ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
      ///receive notifications upon any changes to the channel graph topology from
      ///the point of view of the responding node. Events notified include: new
      ///nodes coming online, nodes updating their authenticated attributes, new
      ///channels being advertised, updates in the routing policy for a directional
      ///channel edge, and when channels are closed on-chain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.GraphTopologyUpdate> SubscribeChannelGraph(global::Lnrpc.GraphTopologySubscription request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubscribeChannelGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
      ///receive notifications upon any changes to the channel graph topology from
      ///the point of view of the responding node. Events notified include: new
      ///nodes coming online, nodes updating their authenticated attributes, new
      ///channels being advertised, updates in the routing policy for a directional
      ///channel edge, and when channels are closed on-chain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.GraphTopologyUpdate> SubscribeChannelGraph(global::Lnrpc.GraphTopologySubscription request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribeChannelGraph, null, options, request);
      }
      /// <summary>
      /// lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DebugLevelResponse DebugLevel(global::Lnrpc.DebugLevelRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DebugLevel(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DebugLevelResponse DebugLevel(global::Lnrpc.DebugLevelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DebugLevel, null, options, request);
      }
      /// <summary>
      /// lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DebugLevelResponse> DebugLevelAsync(global::Lnrpc.DebugLevelRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DebugLevelAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DebugLevelResponse> DebugLevelAsync(global::Lnrpc.DebugLevelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DebugLevel, null, options, request);
      }
      /// <summary>
      /// lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.FeeReportResponse FeeReport(global::Lnrpc.FeeReportRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FeeReport(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.FeeReportResponse FeeReport(global::Lnrpc.FeeReportRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_FeeReport, null, options, request);
      }
      /// <summary>
      /// lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.FeeReportResponse> FeeReportAsync(global::Lnrpc.FeeReportRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FeeReportAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.FeeReportResponse> FeeReportAsync(global::Lnrpc.FeeReportRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_FeeReport, null, options, request);
      }
      /// <summary>
      /// lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PolicyUpdateResponse UpdateChannelPolicy(global::Lnrpc.PolicyUpdateRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UpdateChannelPolicy(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PolicyUpdateResponse UpdateChannelPolicy(global::Lnrpc.PolicyUpdateRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_UpdateChannelPolicy, null, options, request);
      }
      /// <summary>
      /// lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PolicyUpdateResponse> UpdateChannelPolicyAsync(global::Lnrpc.PolicyUpdateRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UpdateChannelPolicyAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PolicyUpdateResponse> UpdateChannelPolicyAsync(global::Lnrpc.PolicyUpdateRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_UpdateChannelPolicy, null, options, request);
      }
      /// <summary>
      /// lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLCs forwarded within the target time range, and integer offset
      ///within that time range, for a maximum number of events. If no maximum number
      ///of events is specified, up to 100 events will be returned. If no time-range
      ///is specified, then events will be returned in the order that they occured.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries. Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ForwardingHistoryResponse ForwardingHistory(global::Lnrpc.ForwardingHistoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ForwardingHistory(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLCs forwarded within the target time range, and integer offset
      ///within that time range, for a maximum number of events. If no maximum number
      ///of events is specified, up to 100 events will be returned. If no time-range
      ///is specified, then events will be returned in the order that they occured.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries. Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ForwardingHistoryResponse ForwardingHistory(global::Lnrpc.ForwardingHistoryRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ForwardingHistory, null, options, request);
      }
      /// <summary>
      /// lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLCs forwarded within the target time range, and integer offset
      ///within that time range, for a maximum number of events. If no maximum number
      ///of events is specified, up to 100 events will be returned. If no time-range
      ///is specified, then events will be returned in the order that they occured.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries. Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ForwardingHistoryResponse> ForwardingHistoryAsync(global::Lnrpc.ForwardingHistoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ForwardingHistoryAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLCs forwarded within the target time range, and integer offset
      ///within that time range, for a maximum number of events. If no maximum number
      ///of events is specified, up to 100 events will be returned. If no time-range
      ///is specified, then events will be returned in the order that they occured.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries. Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ForwardingHistoryResponse> ForwardingHistoryAsync(global::Lnrpc.ForwardingHistoryRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ForwardingHistory, null, options, request);
      }
      /// <summary>
      /// lncli: `exportchanbackup`
      ///ExportChannelBackup attempts to return an encrypted static channel backup
      ///for the target channel identified by it channel point. The backup is
      ///encrypted with a key generated from the aezeed seed of the user. The
      ///returned backup can either be restored using the RestoreChannelBackup
      ///method once lnd is running, or via the InitWallet and UnlockWallet methods
      ///from the WalletUnlocker service.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelBackup ExportChannelBackup(global::Lnrpc.ExportChannelBackupRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ExportChannelBackup(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `exportchanbackup`
      ///ExportChannelBackup attempts to return an encrypted static channel backup
      ///for the target channel identified by it channel point. The backup is
      ///encrypted with a key generated from the aezeed seed of the user. The
      ///returned backup can either be restored using the RestoreChannelBackup
      ///method once lnd is running, or via the InitWallet and UnlockWallet methods
      ///from the WalletUnlocker service.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelBackup ExportChannelBackup(global::Lnrpc.ExportChannelBackupRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ExportChannelBackup, null, options, request);
      }
      /// <summary>
      /// lncli: `exportchanbackup`
      ///ExportChannelBackup attempts to return an encrypted static channel backup
      ///for the target channel identified by it channel point. The backup is
      ///encrypted with a key generated from the aezeed seed of the user. The
      ///returned backup can either be restored using the RestoreChannelBackup
      ///method once lnd is running, or via the InitWallet and UnlockWallet methods
      ///from the WalletUnlocker service.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelBackup> ExportChannelBackupAsync(global::Lnrpc.ExportChannelBackupRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ExportChannelBackupAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `exportchanbackup`
      ///ExportChannelBackup attempts to return an encrypted static channel backup
      ///for the target channel identified by it channel point. The backup is
      ///encrypted with a key generated from the aezeed seed of the user. The
      ///returned backup can either be restored using the RestoreChannelBackup
      ///method once lnd is running, or via the InitWallet and UnlockWallet methods
      ///from the WalletUnlocker service.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelBackup> ExportChannelBackupAsync(global::Lnrpc.ExportChannelBackupRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ExportChannelBackup, null, options, request);
      }
      /// <summary>
      ///
      ///ExportAllChannelBackups returns static channel backups for all existing
      ///channels known to lnd. A set of regular singular static channel backups for
      ///each channel are returned. Additionally, a multi-channel backup is returned
      ///as well, which contains a single encrypted blob containing the backups of
      ///each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChanBackupSnapshot ExportAllChannelBackups(global::Lnrpc.ChanBackupExportRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ExportAllChannelBackups(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///ExportAllChannelBackups returns static channel backups for all existing
      ///channels known to lnd. A set of regular singular static channel backups for
      ///each channel are returned. Additionally, a multi-channel backup is returned
      ///as well, which contains a single encrypted blob containing the backups of
      ///each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChanBackupSnapshot ExportAllChannelBackups(global::Lnrpc.ChanBackupExportRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ExportAllChannelBackups, null, options, request);
      }
      /// <summary>
      ///
      ///ExportAllChannelBackups returns static channel backups for all existing
      ///channels known to lnd. A set of regular singular static channel backups for
      ///each channel are returned. Additionally, a multi-channel backup is returned
      ///as well, which contains a single encrypted blob containing the backups of
      ///each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChanBackupSnapshot> ExportAllChannelBackupsAsync(global::Lnrpc.ChanBackupExportRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ExportAllChannelBackupsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///ExportAllChannelBackups returns static channel backups for all existing
      ///channels known to lnd. A set of regular singular static channel backups for
      ///each channel are returned. Additionally, a multi-channel backup is returned
      ///as well, which contains a single encrypted blob containing the backups of
      ///each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChanBackupSnapshot> ExportAllChannelBackupsAsync(global::Lnrpc.ChanBackupExportRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ExportAllChannelBackups, null, options, request);
      }
      /// <summary>
      ///
      ///VerifyChanBackup allows a caller to verify the integrity of a channel backup
      ///snapshot. This method will accept either a packed Single or a packed Multi.
      ///Specifying both will result in an error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.VerifyChanBackupResponse VerifyChanBackup(global::Lnrpc.ChanBackupSnapshot request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return VerifyChanBackup(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///VerifyChanBackup allows a caller to verify the integrity of a channel backup
      ///snapshot. This method will accept either a packed Single or a packed Multi.
      ///Specifying both will result in an error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.VerifyChanBackupResponse VerifyChanBackup(global::Lnrpc.ChanBackupSnapshot request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_VerifyChanBackup, null, options, request);
      }
      /// <summary>
      ///
      ///VerifyChanBackup allows a caller to verify the integrity of a channel backup
      ///snapshot. This method will accept either a packed Single or a packed Multi.
      ///Specifying both will result in an error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.VerifyChanBackupResponse> VerifyChanBackupAsync(global::Lnrpc.ChanBackupSnapshot request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return VerifyChanBackupAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///VerifyChanBackup allows a caller to verify the integrity of a channel backup
      ///snapshot. This method will accept either a packed Single or a packed Multi.
      ///Specifying both will result in an error.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.VerifyChanBackupResponse> VerifyChanBackupAsync(global::Lnrpc.ChanBackupSnapshot request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_VerifyChanBackup, null, options, request);
      }
      /// <summary>
      /// lncli: `restorechanbackup`
      ///RestoreChannelBackups accepts a set of singular channel backups, or a
      ///single encrypted multi-chan backup and attempts to recover any funds
      ///remaining within the channel. If we are able to unpack the backup, then the
      ///new channel will be shown under listchannels, as well as pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.RestoreBackupResponse RestoreChannelBackups(global::Lnrpc.RestoreChanBackupRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RestoreChannelBackups(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `restorechanbackup`
      ///RestoreChannelBackups accepts a set of singular channel backups, or a
      ///single encrypted multi-chan backup and attempts to recover any funds
      ///remaining within the channel. If we are able to unpack the backup, then the
      ///new channel will be shown under listchannels, as well as pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.RestoreBackupResponse RestoreChannelBackups(global::Lnrpc.RestoreChanBackupRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_RestoreChannelBackups, null, options, request);
      }
      /// <summary>
      /// lncli: `restorechanbackup`
      ///RestoreChannelBackups accepts a set of singular channel backups, or a
      ///single encrypted multi-chan backup and attempts to recover any funds
      ///remaining within the channel. If we are able to unpack the backup, then the
      ///new channel will be shown under listchannels, as well as pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.RestoreBackupResponse> RestoreChannelBackupsAsync(global::Lnrpc.RestoreChanBackupRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return RestoreChannelBackupsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `restorechanbackup`
      ///RestoreChannelBackups accepts a set of singular channel backups, or a
      ///single encrypted multi-chan backup and attempts to recover any funds
      ///remaining within the channel. If we are able to unpack the backup, then the
      ///new channel will be shown under listchannels, as well as pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.RestoreBackupResponse> RestoreChannelBackupsAsync(global::Lnrpc.RestoreChanBackupRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_RestoreChannelBackups, null, options, request);
      }
      /// <summary>
      ///
      ///SubscribeChannelBackups allows a client to sub-subscribe to the most up to
      ///date information concerning the state of all channel backups. Each time a
      ///new channel is added, we return the new set of channels, along with a
      ///multi-chan backup containing the backup info for all channels. Each time a
      ///channel is closed, we send a new update, which contains new new chan back
      ///ups, but the updated set of encrypted multi-chan backups with the closed
      ///channel(s) removed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.ChanBackupSnapshot> SubscribeChannelBackups(global::Lnrpc.ChannelBackupSubscription request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SubscribeChannelBackups(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///SubscribeChannelBackups allows a client to sub-subscribe to the most up to
      ///date information concerning the state of all channel backups. Each time a
      ///new channel is added, we return the new set of channels, along with a
      ///multi-chan backup containing the backup info for all channels. Each time a
      ///channel is closed, we send a new update, which contains new new chan back
      ///ups, but the updated set of encrypted multi-chan backups with the closed
      ///channel(s) removed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.ChanBackupSnapshot> SubscribeChannelBackups(global::Lnrpc.ChannelBackupSubscription request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribeChannelBackups, null, options, request);
      }
      /// <summary>
      /// lncli: `bakemacaroon`
      ///BakeMacaroon allows the creation of a new macaroon with custom read and
      ///write permissions. No first-party caveats are added since this can be done
      ///offline.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.BakeMacaroonResponse BakeMacaroon(global::Lnrpc.BakeMacaroonRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return BakeMacaroon(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `bakemacaroon`
      ///BakeMacaroon allows the creation of a new macaroon with custom read and
      ///write permissions. No first-party caveats are added since this can be done
      ///offline.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.BakeMacaroonResponse BakeMacaroon(global::Lnrpc.BakeMacaroonRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_BakeMacaroon, null, options, request);
      }
      /// <summary>
      /// lncli: `bakemacaroon`
      ///BakeMacaroon allows the creation of a new macaroon with custom read and
      ///write permissions. No first-party caveats are added since this can be done
      ///offline.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.BakeMacaroonResponse> BakeMacaroonAsync(global::Lnrpc.BakeMacaroonRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return BakeMacaroonAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `bakemacaroon`
      ///BakeMacaroon allows the creation of a new macaroon with custom read and
      ///write permissions. No first-party caveats are added since this can be done
      ///offline.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.BakeMacaroonResponse> BakeMacaroonAsync(global::Lnrpc.BakeMacaroonRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_BakeMacaroon, null, options, request);
      }
      /// <summary>
      /// lncli: `listmacaroonids`
      ///ListMacaroonIDs returns all root key IDs that are in use.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListMacaroonIDsResponse ListMacaroonIDs(global::Lnrpc.ListMacaroonIDsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListMacaroonIDs(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listmacaroonids`
      ///ListMacaroonIDs returns all root key IDs that are in use.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListMacaroonIDsResponse ListMacaroonIDs(global::Lnrpc.ListMacaroonIDsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListMacaroonIDs, null, options, request);
      }
      /// <summary>
      /// lncli: `listmacaroonids`
      ///ListMacaroonIDs returns all root key IDs that are in use.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListMacaroonIDsResponse> ListMacaroonIDsAsync(global::Lnrpc.ListMacaroonIDsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListMacaroonIDsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listmacaroonids`
      ///ListMacaroonIDs returns all root key IDs that are in use.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListMacaroonIDsResponse> ListMacaroonIDsAsync(global::Lnrpc.ListMacaroonIDsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListMacaroonIDs, null, options, request);
      }
      /// <summary>
      /// lncli: `deletemacaroonid`
      ///DeleteMacaroonID deletes the specified macaroon ID and invalidates all
      ///macaroons derived from that ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DeleteMacaroonIDResponse DeleteMacaroonID(global::Lnrpc.DeleteMacaroonIDRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteMacaroonID(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `deletemacaroonid`
      ///DeleteMacaroonID deletes the specified macaroon ID and invalidates all
      ///macaroons derived from that ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DeleteMacaroonIDResponse DeleteMacaroonID(global::Lnrpc.DeleteMacaroonIDRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeleteMacaroonID, null, options, request);
      }
      /// <summary>
      /// lncli: `deletemacaroonid`
      ///DeleteMacaroonID deletes the specified macaroon ID and invalidates all
      ///macaroons derived from that ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DeleteMacaroonIDResponse> DeleteMacaroonIDAsync(global::Lnrpc.DeleteMacaroonIDRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeleteMacaroonIDAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `deletemacaroonid`
      ///DeleteMacaroonID deletes the specified macaroon ID and invalidates all
      ///macaroons derived from that ID.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DeleteMacaroonIDResponse> DeleteMacaroonIDAsync(global::Lnrpc.DeleteMacaroonIDRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeleteMacaroonID, null, options, request);
      }
      /// <summary>
      /// lncli: `listpermissions`
      ///ListPermissions lists all RPC method URIs and their required macaroon
      ///permissions to access them.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPermissionsResponse ListPermissions(global::Lnrpc.ListPermissionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListPermissions(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listpermissions`
      ///ListPermissions lists all RPC method URIs and their required macaroon
      ///permissions to access them.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPermissionsResponse ListPermissions(global::Lnrpc.ListPermissionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListPermissions, null, options, request);
      }
      /// <summary>
      /// lncli: `listpermissions`
      ///ListPermissions lists all RPC method URIs and their required macaroon
      ///permissions to access them.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPermissionsResponse> ListPermissionsAsync(global::Lnrpc.ListPermissionsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ListPermissionsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      /// lncli: `listpermissions`
      ///ListPermissions lists all RPC method URIs and their required macaroon
      ///permissions to access them.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPermissionsResponse> ListPermissionsAsync(global::Lnrpc.ListPermissionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListPermissions, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override LightningClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new LightningClient(configuration);
      }
    }

  }
}
#endregion
